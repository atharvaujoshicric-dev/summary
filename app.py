import streamlit as st
import pandas as pd
import re
import io
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import formataddr
from email import encoders
from openpyxl.styles import Alignment, PatternFill, Border, Side

# --- EMAIL CONFIGURATION ---
SENDER_EMAIL = "atharvaujoshi@gmail.com"
SENDER_NAME = "Spydarr Market Research" 
APP_PASSWORD = "nybl zsnx zvdw edqr"

def send_email(recipient_email, excel_data, filename):
    try:
        recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()
        msg = MIMEMultipart()
        msg['From'] = formataddr((SENDER_NAME, SENDER_EMAIL))
        msg['To'] = recipient_email
        msg['Subject'] = "Spydarr Market Research Summary"
        
        body = f"""Dear {recipient_name},

Please find the attached professional property analysis report generated by the dashboard.

Regards,
Atharva Joshi"""

        msg.attach(MIMEText(body, 'plain'))
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(excel_data)
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename={filename}")
        msg.attach(part)
        
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(SENDER_EMAIL, APP_PASSWORD)
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        st.error(f"Error sending email: {e}")
        return False

def extract_area_logic(text):
    if pd.isna(text) or text == "": return 0.0
    
    # 1. Cleanup & Standardization
    text = " ".join(str(text).split())
    text = re.sub(r'[मक]हणज[चछ]े', 'म्हणजे', text)
    text = re.sub(r'(\d+)\.\.(\d+)', r'\1.\2', text)
    text = re.sub(r'(\d+)\s*\.\s*(\d+)', r'\1.\2', text)
    text = re.sub(r'(\d+\.\d+)\.', r'\1', text)
    text = re.sub(r'(\d+\.?)\s+(\d+)', r'\1\2', text) 
    text = re.sub(r'(\d),(\d)', r'\1\2', text) 
    text = re.sub(r'\d+\.?\d*\s*[\*xX]\s*\d+\.?\d*', 'PARKING_DIM', text)

    # 2. Unit Patterns
    m_unit = r'(?:चौरस\s*मी(?:[टत]र)?|चौ[\.\s]*मी[\.\s]*|चाै[\.\s]*मी[\.\s]*|sq\.?\s*m(?:tr)?\.?|square\s*meter(?:s)?)(?:\s*कार्?पेट)?(?:\s*एरिया|area)?'
    f_unit = r'(?:चौरस\s*फु[टत]|चौरस\s*फू[टत]|चौ[\.\s]*फू|sq\.?\s*f(?:t)?\.?|square\s*f(?:ee|oo)t)(?:\s*area)?'
    
    # 3. Context Filtering
    start_keywords = r'(?:इमारतीमधील|गृहप्रकल्पातील|प्रकल्पातील|योजनेतील|नियोजित|प्रोजेक्ट|प्रोजेक्टमधील|बिल्डींग|इमारत|मिळकतीवर|मिळकतीवरील|प्रकलप|प्रकल्पात|फ्लॅट|अपार्टमेंट)'
    parts = re.split(start_keywords, text, flags=re.IGNORECASE)
    relevant_text = " ".join(parts[1:]) if len(parts) > 1 else text

    # 4. Explicit Total Area Priority
    total_markers = r'(?:एकूण|असे एकूण|टोटल|total)\s*क्षेत्र'
    total_match = re.search(rf'{total_markers}\s*(?:क्षेत्र\s*)?(\d+\.?\d*)\s*{m_unit}', relevant_text, re.IGNORECASE)
    if total_match:
        return round(float(total_match.group(1)), 3)

    # 5. Metric Summation
    exclude_keywords = ["पार्किंग", "पार्कींग", "parking", "road", "reserve", "राखीव", "प्लॉट", "plot", "साईज", "size"]
    m_vals = []
    
    for match in re.finditer(rf'(\d+\.?\d*)\s*{m_unit}', relevant_text, re.IGNORECASE):
        val = float(match.group(1))
        ctx_before = relevant_text[max(0, match.start()-60):match.start()].lower()
        bracket_ctx = relevant_text[max(0, match.start()-100):match.start()]
        is_rera_dup = "(" in bracket_ctx and "रेरा" in bracket_ctx and ")" not in bracket_ctx
        
        if not any(word in ctx_before for word in exclude_keywords) and not is_rera_dup:
            if 2.0 <= val < 900:
                if val not in m_vals: m_vals.append(val)
            
    if m_vals:
        if len(m_vals) > 1:
            m_vals.sort()
            largest = m_vals[-1]
            others_sum = sum(m_vals[:-1])
            if abs(largest - others_sum) < 1.0:
                return round(largest, 3)
        return round(sum(m_vals), 3)

    # 6. Imperial Fallback (SQ.FT)
    f_vals = []
    for match in re.finditer(rf'(\d+\.?\d*)\s*{f_unit}', relevant_text, re.IGNORECASE):
        val = float(match.group(1))
        ctx_before = relevant_text[max(0, match.start()-60):match.start()].lower()
        if not any(word in ctx_before for word in exclude_keywords):
            if 20.0 <= val < 9000:
                if val not in f_vals: f_vals.append(val)
                
    if f_vals:
        if len(f_vals) > 1:
            f_vals.sort()
            largest = f_vals[-1]
            others_sum = sum(f_vals[:-1])
            if abs(largest - others_sum) < 5.0:
                return round(largest / 10.764, 3)
        return round(sum(f_vals) / 10.764, 3)
        
    return 0.0

def determine_config(area_sqft, t1, t2, t3):
    if area_sqft == 0: return "N/A"
    if area_sqft <= t1: return "1 BHK"
    elif area_sqft <= t2: return "2 BHK"
    elif area_sqft <= t3: return "3 BHK"
    else: return "4 BHK"

def apply_excel_formatting(df, writer, sheet_name, is_summary=True):
    df.to_excel(writer, sheet_name=sheet_name, index=False)
    worksheet = writer.sheets[sheet_name]
    worksheet.freeze_panes = "A2"
    center_align = Alignment(horizontal='center', vertical='center', wrap_text=True)
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    colors = ["A2D2FF", "FFD6A5", "CAFFBF", "FDFFB6", "FFADAD", "BDB2FF", "9BF6FF"]
    
    for i in range(1, worksheet.max_row + 1):
        for j in range(1, worksheet.max_column + 1):
            cell = worksheet.cell(row=i, column=j)
            cell.alignment = center_align
            if is_summary: cell.border = thin_border

    if is_summary:
        color_idx, start_row_prop = 0, 2
        start_row_loc = 2
        last_col = len(df.columns)
        white_fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")

        for i in range(2, len(df) + 3):
            curr_loc = df.iloc[i-2, 0] if i-2 < len(df) else None
            prev_loc = df.iloc[i-3, 0] if i-3 >= 0 else None
            curr_prop = df.iloc[i-2, 1] if i-2 < len(df) else None
            prev_prop = df.iloc[i-3, 1] if i-3 >= 0 else None
            
            if curr_prop != prev_prop and i > 2:
                fill = PatternFill(start_color=colors[color_idx % len(colors)], end_color=colors[color_idx % len(colors)], fill_type="solid")
                for r in range(start_row_prop, i):
                    for c in range(2, last_col + 1):
                        worksheet.cell(row=r, column=c).fill = fill
                if i-1 > start_row_prop:
                    worksheet.merge_cells(start_row=start_row_prop, start_column=2, end_row=i-1, end_column=2)
                    worksheet.merge_cells(start_row=start_row_prop, start_column=last_col, end_row=i-1, end_column=last_col)
                start_row_prop = i
                color_idx += 1

            if curr_loc != prev_loc and i > 2:
                for r in range(start_row_loc, i):
                    worksheet.cell(row=r, column=1).fill = white_fill
                if i-1 > start_row_loc:
                    worksheet.merge_cells(start_row=start_row_loc, start_column=1, end_row=i-1, end_column=1)
                start_row_loc = i

# --- STREAMLIT UI SETUP ---
st.set_page_config(page_title="Spydarr Dashboard", layout="wide")
st.title("Spydarr Dashboard")
st.divider()

# Thresholds from Sidebar (Defined here so they are available for the logic below)
st.sidebar.header("Calculation Settings")
loading_factor = st.sidebar.number_input("Loading Factor", min_value=1.0, value=1.35, step=0.001, format="%.3f")
t1 = st.sidebar.number_input("1 BHK Threshold (SQ.FT)", value=600)
t2 = st.sidebar.number_input("2 BHK Threshold (SQ.FT)", value=850)
t3 = st.sidebar.number_input("3 BHK Threshold (SQ.FT)", value=1100)

uploaded_file = st.file_uploader("Upload Data File", type=["xlsx", "csv"])

if uploaded_file:
    # Load Data
    df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith('.csv') else pd.read_excel(uploaded_file)
    clean_cols = {c.lower().strip(): c for c in df.columns}
    
    desc_col = clean_cols.get('property description')
    cons_col = clean_cols.get('consideration value')
    prop_col = clean_cols.get('property')
    date_col = clean_cols.get('completion date')
    loc_col = clean_cols.get('micromarket')
    
    if desc_col and cons_col and prop_col and date_col and loc_col:
        with st.spinner('Calculating...'):
            # 1. Area Extraction
            df['Carpet Area (SQ.MT)'] = df[desc_col].apply(extract_area_logic)
            df['Carpet Area (SQ.FT)'] = (df['Carpet Area (SQ.MT)'] * 10.764).round(3)
            df['Saleable Area'] = (df['Carpet Area (SQ.FT)'] * loading_factor).round(3)
            
            # 2. APR Calculation
            df['APR'] = df.apply(lambda r: round(r[cons_col]/r['Saleable Area'], 3) if r['Saleable Area'] > 0 else 0, axis=1)
            
            # 3. Configuration Mapping (Using sidebar thresholds)
            df['Configuration'] = df['Carpet Area (SQ.FT)'].apply(lambda x: determine_config(x, t1, t2, t3))
            
            # 4. Processing & Sorting
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            valid_df = df[df['Carpet Area (SQ.FT)'] > 0].sort_values([loc_col, prop_col, 'Configuration', 'Carpet Area (SQ.FT)'])
            
            # 5. Summary Aggregation
            project_counts = valid_df.groupby(prop_col).size().reset_index(name='Total Count')
            summary = valid_df.groupby([loc_col, prop_col, 'Configuration', 'Carpet Area (SQ.FT)']).agg(
                Last_Date=(date_col, 'max'),
                Min_APR=('APR', 'min'), 
                Max_APR=('APR', 'max'), 
                Avg_APR=('APR', 'mean'),
                Median_APR=('APR', 'median'),
                Property_Count=(prop_col, 'count')
            ).reset_index()
            
            summary = summary.merge(project_counts, on=prop_col, how='left')
            summary['Last_Date'] = pd.to_datetime(summary['Last_Date'], errors='coerce').apply(lambda x: x.strftime('%b-%Y') if pd.notnull(x) else "N/A")
            
            summary.columns = ['Location', 'Property', 'Configuration', 'Carpet Area(SQ.FT)', 'Last Completion Date', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Count of Property', 'Total Count']
            summary = summary[['Location', 'Property', 'Last Completion Date', 'Configuration', 'Carpet Area(SQ.FT)', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Count of Property', 'Total Count']]

            # 6. Excel Generation
            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                apply_excel_formatting(df, writer, 'Raw Data', is_summary=False)
                apply_excel_formatting(summary, writer, 'Summary', is_summary=True)
            
            st.success("Analysis Complete!")
            
            # 7. Email Section
            recipient = st.text_input("Recipient Name (for beyondwalls.com)", placeholder="firstname.lastname")
            if st.button("Send to Email"):
                if recipient:
                    full_email = f"{recipient.strip().lower()}@beyondwalls.com"
                    if send_email(full_email, output.getvalue(), "Spydarr_Market_Summary.xlsx"):
                        st.success(f"Report sent to {full_email}")
                else:
                    st.warning("Please enter a recipient name first.")
    else:
        st.error("Missing required columns in uploaded file. Check for: Micromarket, Property Description, Consideration Value, Property, and Completion Date.")
