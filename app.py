import streamlit as st
import pandas as pd
import re
import io
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import formataddr
from email import encoders
from openpyxl.styles import Alignment, PatternFill, Border, Side

# --- EMAIL CONFIGURATION ---
SENDER_EMAIL = "atharvaujoshi@gmail.com"
SENDER_NAME = "Spydarr Market Research" 
APP_PASSWORD = "nybl zsnx zvdw edqr"

def send_email(recipient_email, excel_data, filename):
    try:
        recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()
        msg = MIMEMultipart()
        msg['From'] = formataddr((SENDER_NAME, SENDER_EMAIL))
        msg['To'] = recipient_email
        msg['Subject'] = "Spydarr Market Research Summary"
        
        body = f"""Dear {recipient_name},

Please find the attached professional property analysis report generated by the dashboard.

The report includes:
1. Raw Data with calculated APR and Configurations.
2. A summarized view of APR statistics across properties.

Regards,
Atharva Joshi"""

        msg.attach(MIMEText(body, 'plain'))
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(excel_data)
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename={filename}")
        msg.attach(part)
        
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(SENDER_EMAIL, APP_PASSWORD)
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        st.error(f"Error sending email: {e}")
        return False

def extract_area_logic(text):
    if pd.isna(text) or text == "": return 0.0
    
    # 1. CLEANUP & FIX: Standardize whitespace and common typos
    text = " ".join(str(text).split())
    text = re.sub(r'म्हणज[च]े', 'म्हणजे', text)
    text = re.sub(r'(\d+)\.\.(\d+)', r'\1.\2', text)
    text = re.sub(r'(\d+)\s*\.\s*(\d+)', r'\1.\2', text)
    text = re.sub(r'(\d+\.\d+)\.', r'\1', text)
    text = re.sub(r'(\d+\.?)\s+(\d+)', r'\1\2', text) 
    text = re.sub(r'(\d),(\d)', r'\1\2', text) 
    text = re.sub(r'\d+\.?\d*\s*[\*x]\s*\d+\.?\d*', 'PARKING_DIM', text)

    # 2. UNIT PATTERNS: Enhanced to catch "Chatai Kshetra" and variations
    m_unit = r'(?:चौरस\s*मी(?:[टत]र)?|चौ[\.\s]*मी[\.\s]*|चाै[\.\s]*मी[\.\s]*|sq\.?\s*m(?:tr)?\.?|square\s*meter(?:s)?)(?:\s*(?:कारपेट|कार्पेट|चटई क्षेत्र))?(?:\s*(?:एरिया|area|क्षेत्र))?'
    f_unit = r'(?:चौरस\s*फु[टत]|चौरस\s*फू[टत]|चौ[\.\s]*फु[टत]?|चौ[\.\s]*फू[टत]?|sq\.?\s*f(?:t)?\.?|square\s*f(?:ee|oo)t)(?:\s*(?:area|क्षेत्र))?'
    
    # 3. FOCUS LOGIC: isolate unit details from land stats
    # Added "सेक्टर" and "क्लस्टर" as boundary markers
    boundary_keywords = r'(?:येथील|मिळकतीवर|मिळकतीवरील|बांधण्यात|बांधत|प्रकल्पातील|गृहप्रकल्पातील|इमारतप्रकल्पातील|योजनेतील|नियोजित|इमारतीमधील|बिल्डींग|बिल्डिंग|प्रकल्प|टावर|टॉवर|प्रिस्टीन|सेक्टर|क्लस्टर)'
    parts = re.split(boundary_keywords, text, flags=re.IGNORECASE)
    relevant_text = " ".join(parts[1:]) if len(parts) > 1 else text

    # UPDATED: Removed "एकूण क्षेत्र" from exclusions to capture flat totals
    exclude_keywords = ["पार्किंग", "पार्कींग", "parking", "road", "reserve", "राखीव", "प्लॉट", "plot", "वाढीव", "पैकी", "अविभक्त", "साईज", "size", "बिल्डअप", "मुल्यांकन", "दर", "rate", "७/१२", "नाकाश"]
    
    # 4. METRIC SUMMATION
    m_vals = []
    for match in re.finditer(rf'(\d+\.?\d*)\s?{m_unit}', relevant_text, re.IGNORECASE):
        val = float(match.group(1))
        start_idx = match.start()
        context_before = relevant_text[max(0, start_idx-60):start_idx].lower()
        bracket_context = relevant_text[max(0, start_idx-150):start_idx]
        is_rera_duplicate = "(" in bracket_context and "रेरा" in bracket_context and ")" not in bracket_context
        
        if not any(word in context_before for word in exclude_keywords):
            if 2.0 <= val < 900 and not is_rera_duplicate:
                if not m_vals or val != m_vals[-1]:
                    m_vals.append(val)
            
    if m_vals:
        # Cross-check if any value is the stated total of others
        if len(m_vals) > 1:
            for i in range(1, len(m_vals)):
                if abs(m_vals[i] - sum(m_vals[:i])) < 1.0:
                    return round(m_vals[i], 3)
        return round(sum(m_vals), 3)

    # 5. IMPERIAL SUMMATION FALLBACK
    f_vals = []
    for match in re.finditer(rf'(\d+\.?\d*)\s?{f_unit}', relevant_text, re.IGNORECASE):
        val = float(match.group(1))
        start_idx = match.start()
        context_before = relevant_text[max(0, match.start()-60):start_idx].lower()
        if not any(word in context_before for word in exclude_keywords):
            if 20.0 <= val < 9000:
                if not f_vals or val != f_vals[-1]:
                    f_vals.append(val)
                
    if f_vals:
        if len(f_vals) > 1:
            for i in range(1, len(f_vals)):
                if abs(f_vals[i] - sum(f_vals[:i])) < 5.0:
                    return round(f_vals[i] / 10.764, 3)
        return round(sum(f_vals) / 10.764, 3)
        
    return 0.0

def determine_config(area, t1, t2, t3):
    if area == 0: return "N/A"
    if area < t1: return "1 BHK"
    elif area < t2: return "2 BHK"
    elif area < t3: return "3 BHK"
    else: return "4 BHK"

def apply_excel_formatting(df, writer, sheet_name, is_summary=True):
    df.to_excel(writer, sheet_name=sheet_name, index=False)
    worksheet = writer.sheets[sheet_name]
    worksheet.freeze_panes = "A2"
    center_align = Alignment(horizontal='center', vertical='center', wrap_text=True)
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))
    colors = ["A2D2FF", "FFD6A5", "CAFFBF", "FDFFB6", "FFADAD", "BDB2FF", "9BF6FF"]
    
    for i in range(1, worksheet.max_row + 1):
        for j in range(1, worksheet.max_column + 1):
            cell = worksheet.cell(row=i, column=j)
            cell.alignment = center_align
            if is_summary: cell.border = thin_border

    if is_summary:
        color_idx, start_row_prop = 0, 2
        start_row_loc = 2
        last_col = len(df.columns)
        white_fill = PatternFill(start_color="FFFFFF", end_color="FFFFFF", fill_type="solid")

        for i in range(2, len(df) + 3):
            curr_loc = df.iloc[i-2, 0] if i-2 < len(df) else None
            prev_loc = df.iloc[i-3, 0] if i-3 >= 0 else None
            curr_prop = df.iloc[i-2, 1] if i-2 < len(df) else None
            prev_prop = df.iloc[i-3, 1] if i-3 >= 0 else None
            
            if curr_prop != prev_prop and i > 2:
                fill = PatternFill(start_color=colors[color_idx % len(colors)], end_color=colors[color_idx % len(colors)], fill_type="solid")
                for r in range(start_row_prop, i):
                    for c in range(2, last_col + 1):
                        worksheet.cell(row=r, column=c).fill = fill
                if i-1 > start_row_prop:
                    worksheet.merge_cells(start_row=start_row_prop, start_column=2, end_row=i-1, end_column=2)
                    worksheet.merge_cells(start_row=start_row_prop, start_column=last_col, end_row=i-1, end_column=last_col)
                start_row_prop = i
                color_idx += 1

            if curr_loc != prev_loc and i > 2:
                for r in range(start_row_loc, i):
                    worksheet.cell(row=r, column=1).fill = white_fill
                if i-1 > start_row_loc:
                    worksheet.merge_cells(start_row=start_row_loc, start_column=1, end_row=i-1, end_column=1)
                start_row_loc = i

# --- STREAMLIT UI ---
st.set_page_config(page_title="Spydarr Dashboard", layout="wide")
st.title("Spydarr Dashboard")
st.markdown("<div style='margin-top: -15px; margin-bottom: 5px;'><span style='background-color: #FFFF00; padding: 2px 8px; border-radius: 4px; border: 1px solid #E6E600; font-size: 0.9em; color: black;'><u><strong>NOTE :-</strong> Please cross-check the report manually.</u></span></div>", unsafe_allow_html=True)
st.markdown("[Property Report Tool · Streamlit](https://summarybeyondwalls.streamlit.app/)")
st.divider()

st.sidebar.header("Calculation Settings")
loading_factor = st.sidebar.number_input("Loading Factor", min_value=1.0, value=1.35, step=0.001, format="%.3f")
t1 = st.sidebar.number_input("1 BHK Threshold", value=600)
t2 = st.sidebar.number_input("2 BHK Threshold", value=850)
t3 = st.sidebar.number_input("3 BHK Threshold", value=1100)

uploaded_file = st.file_uploader("Upload Data File", type=["xlsx", "csv"])
if uploaded_file:
    df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith('.csv') else pd.read_excel(uploaded_file)
    clean_cols = {c.lower().strip(): c for c in df.columns}
    desc_col = clean_cols.get('property description')
    cons_col = clean_cols.get('consideration value')
    prop_col = clean_cols.get('property')
    date_col = clean_cols.get('completion date')
    loc_col = clean_cols.get('micromarket')
    
    if desc_col and cons_col and prop_col and date_col and loc_col:
        with st.spinner('Calculating...'):
            df['Carpet Area (SQ.MT)'] = df[desc_col].apply(extract_area_logic)
            df['Carpet Area (SQ.FT)'] = (df['Carpet Area (SQ.MT)'] * 10.764).round(3)
            df['Saleable Area'] = (df['Carpet Area (SQ.FT)'] * loading_factor).round(3)
            df['APR'] = df.apply(lambda r: round(r[cons_col]/r['Saleable Area'], 3) if r['Saleable Area'] > 0 else 0, axis=1)
            df['Configuration'] = df['Carpet Area (SQ.FT)'].apply(lambda x: determine_config(x, t1, t2, t3))
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            
            valid_df = df[df['Carpet Area (SQ.FT)'] > 0].sort_values([loc_col, prop_col, 'Configuration', 'Carpet Area (SQ.FT)'])
            
            project_counts = valid_df.groupby(prop_col).size().reset_index(name='Total Count')
            summary = valid_df.groupby([loc_col, prop_col, 'Configuration', 'Carpet Area (SQ.FT)']).agg(
                Last_Date=(date_col, 'max'),
                Min_APR=('APR', 'min'), 
                Max_APR=('APR', 'max'), 
                Avg_APR=('APR', 'mean'),
                Median_APR=('APR', 'median'),
                Property_Count=(prop_col, 'count')
            ).reset_index()
            
            summary = summary.merge(project_counts, on=prop_col, how='left')
            summary['Last_Date'] = pd.to_datetime(summary['Last_Date'], errors='coerce')
            summary['Last_Date'] = summary['Last_Date'].apply(lambda x: x.strftime('%b-%Y') if pd.notnull(x) else "N/A")
            
            summary.columns = ['Location', 'Property', 'Configuration', 'Carpet Area(SQ.FT)', 'Last Completion Date', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Count of Property', 'Total Count']
            summary = summary[['Location', 'Property', 'Last Completion Date', 'Configuration', 'Carpet Area(SQ.FT)', 'Min. APR', 'Max APR', 'Average of APR', 'Median of APR', 'Count of Property', 'Total Count']]

            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                apply_excel_formatting(df, writer, 'Raw Data', is_summary=False)
                apply_excel_formatting(summary, writer, 'Summary', is_summary=True)
            
            st.success("Analysis Complete!")
            recipient = st.text_input("Recipient Name", placeholder="firstname.lastname")
            if st.button("Send to Email") and recipient:
                full_email = f"{recipient.strip().lower()}@beyondwalls.com"
                if send_email(full_email, output.getvalue(), "Spydarr_Market_Report.xlsx"):
                    st.success(f"Report sent to {full_email}")
    else:
        st.error("Missing required columns. Ensure file has 'Micromarket', 'Property Description', 'Consideration Value', 'Property', and 'Completion Date'.")
